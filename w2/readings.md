
# Week 2: Time Complexity and Problem Solving

Problems & Understanding:
- **This week's lecture notes!** Ashesh has done an amazing job succinctly compiling
  all the information you'd want for this course on those slides. They were
  pivotal to my success both in COMP2521 and in future courses.
- **Structure and Interpretation of Programs (SICP) | Chapter 1.2:** [This chapter](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2) 
  unravels the mechanisms behind procedure calls, and goes further into
  time complexity. A ton of great exercises here to get you a ton more
  experienced with reasoning about the efficiency of your programs. The programs
  are written in Scheme, but it's fairly readable (and the language is quite
  small, so you could learn it pretty confidently in about an hour!)
- **Solving Recurrences | Stanford CS161 Notes:** A recurrence is some relation
  that's defined in terms of itself (covered in MATH1081). They come up a ton
  when you're trying to ascertain the BigO of some algorithm that uses divide
  and conquer in order to solve the problem e.g. binary search. [These notes](https://web.stanford.edu/class/archive/cs/cs161/cs161.1168/lecture3.pdf)
  guide you through how to find a closed form of a recurrence without any reference to 
  itself, hence enabling you to analyse some divide and conquer algorithms.

Towards Mastery:
- **Algorithmically slanted problems:** Big-O notation is a tool to be used to
  help you think about the efficiency of your programs. The best way to see it
  in practice is to write your own algorithms to problems and to always to look
  to improve your solutions. Understanding time complexity will come naturally
  from looking to improve your algorithm. My favourite website for problems is
  [USACO](https://train.usaco.org/usacogate).
- **Learn a bit about problems in Computational Complexity:** 
